--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         48234496 B, 64 B, 23-way associative
Command:          ./MD
Data file:        cachegrind_output.txt
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
         Ir  I1mr  ILmr          Dr       D1mr       DLmr          Dw      D1mw      DLmw 
--------------------------------------------------------------------------------
550,132,191 1,581 1,559 152,020,058 18,999,911 10,798,839 149,625,474 4,210,012 4,209,941  PROGRAM TOTALS

--------------------------------------------------------------------------------
         Ir I1mr ILmr         Dr       D1mr      DLmr         Dw      D1mw      DLmw  file:function
--------------------------------------------------------------------------------
279,417,433   47   47 96,567,428 15,833,093 7,641,290 65,033,936 3,145,478 3,145,476  /lustre/home/d167/s1770309/PP/performance_programming_coursework/src/MD.c:evolve.V
 67,126,356    8    8 25,171,968  3,149,582 3,144,963      6,144     1,539     1,539  /lustre/home/d167/s1770309/PP/performance_programming_coursework/src/util.h:evolve.V
 67,092,513    6    6          2          2         2 67,092,480 1,048,321 1,048,321  ???:__intel_avx_rep_memset
 35,609,301  103  100  7,386,662         12        11  5,359,777     8,198     8,198  ???:__printf_fp
 26,100,773   68   68  7,720,964      9,296     9,290  2,584,580     4,619     4,619  ???:_IO_vfscanf
 18,740,564   53   53  2,628,836          4         4  1,380,234         4         3  ???:____strtod_l_internal
 11,536,490    6    6  3,828,230          0         0  1,782,476         1         1  ???:hack_digit.13574
  8,624,212   65   65  1,970,785         32        24  2,003,432        16        12  ???:vfprintf
  8,483,216    7    6  1,249,668          0         0    842,618         1         1  ???:__mpn_mul_1
  4,233,264    7    7    650,954          2         2    364,873         1         1  ???:str_to_mpn.isra.0
  3,935,428    5    5  1,052,767          0         0    971,127         0         0  ???:__mpn_divrem
  2,708,722    6    6    667,908          2         1    549,001         3         3  ???:_IO_file_xsputn@@GLIBC_2.2.5
  1,903,354    8    8    258,048          0         0    239,004         1         1  ???:round_and_return
  1,585,164    2    2    442,373          0         0    110,593         0         0  ???:read_int
  1,585,009    4    4    211,335          0         0    105,668         0         0  ???:__mpn_lshift
  1,401,148    3    3    155,688          0         0     77,849     1,089     1,088  ???:__GI_mempcpy
  1,362,800    6    6    161,152          1         1     91,522         1         1  ???:__GI_memcpy
  1,089,522    1    1    466,938          0         0    155,646         0         0  ???:_IO_sputbackc
  1,069,056    3    3    258,048          0         0    184,320         0         0  ???:_IO_padn
  1,032,220    7    6    147,460          1         1          0         0         0  ???:__GI_strlen
    942,420    2    2     81,950          3         3          0         0         0  ???:strchrnul
    858,002    7    7    248,369          1         1    225,790         1         1  ???:__mpn_mul
    774,186    4    4     73,732          0         0    184,330         1         1  ???:__mpn_extract_double
    625,022    3    3    110,298          0         0     73,532         0         0  ???:__mpn_rshift

--------------------------------------------------------------------------------
-- Auto-annotated source: /lustre/home/d167/s1770309/PP/performance_programming_coursework/src/MD.c
--------------------------------------------------------------------------------
        Ir I1mr ILmr         Dr      D1mr      DLmr         Dw      D1mw      DLmw 

-- line 2 ----------------------------------------
         .    .    .          .         .         .          .         .         .   *  Simple molecular dynamics code.
         .    .    .          .         .         .          .         .         .   *
         .    .    .          .         .         .          .         .         .   */
         .    .    .          .         .         .          .         .         .  #include <stdio.h>
         .    .    .          .         .         .          .         .         .  #include <math.h>
         .    .    .          .         .         .          .         .         .  #include "coord.h"
         .    .    .          .         .         .          .         .         .  #include "util.h"
         .    .    .          .         .         .          .         .         .  
         1    0    0          1         1         1          0         0         0  void evolve(int count,double dt)
        13    2    2          1         1         0          4         0         0  {
         .    .    .          .         .         .          .         .         .    unsigned int step;
         .    .    .          .         .         .          .         .         .    int i, ii, j, jj, k, l;
         .    .    .          .         .         .          .         .         .    double size;
         .    .    .          .         .         .          .         .         .    double tmp_val, tmp_val2, tmp_val3;
         .    .    .          .         .         .          .         .         .    /*
         .    .    .          .         .         .          .         .         .     * Loop over timesteps.
         .    .    .          .         .         .          .         .         .    */
         .    .    .          .         .         .          .         .         .    count=1;
         .    .    .          .         .         .          .         .         .    for(step = 1;step<=count;++step)
         .    .    .          .         .         .          .         .         .    {
         4    1    1          0         0         0          1         0         0      printf("timestep %d\n",step);
         4    0    0          1         1         0          1         0         0      printf("collisions %d\n",collisions);
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .      /* calculate distance from central mass */
     3,083    2    2          0         0         0          0         0         0      for(i=0;i<Nbody;++i)
         .    .    .          .         .         .          .         .         .      {
         .    .    .          .         .         .          .         .         .        tmp_val = 0.0;
         .    .    .          .         .         .          .         .         .        for(k=0;k<Ndim;++k)
         .    .    .          .         .         .          .         .         .        {
     6,145    1    1      3,072     1,539         0          0         0         0          tmp_val += pow(pos[k][i], 2);
         .    .    .          .         .         .          .         .         .        }
     2,048    0    0          0         0         0      1,024       513       513        r[i] = sqrt(tmp_val);
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .  
        14    2    2          0         0         0          0         0         0      for(j=0;j<Ndim;++j){
     3,072    0    0      3,072     1,539         0          0         0         0        visc_force(Nbody,f[j],vis,velo[j]);
     3,075    2    2      3,075     1,542         0          0         0         0        wind_force(Nbody,f[j],vis,wind[j]);
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .      /* calculate central force */
        14    1    1          0         0         0          0         0         0      for(i=0;i<Ndim;++i)
         .    .    .          .         .         .          .         .         .      {
     2,346    3    3          0         0         0          0         0         0        for(j=0;j<Nbody;++j)
         .    .    .          .         .         .          .         .         .        {
    15,362    3    3      9,218     4,619         1      3,072         0         0          f[i][j] -= force(M_central_x_G*mass[j], pos[i][j], r[j]);
         .    .    .          .         .         .          .         .         .  	    }
         .    .    .          .         .         .          .         .         .  	  }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .      /* calculate pairwise separation of particles */
        28    1    1          6         0         0          4         1         0      for(l=0;l<Ndim;++l)
         .    .    .          .         .         .          .         .         .      {
         3    0    0          0         0         0          0         0         0        k = 0;
    24,588    0    0          3         0         0          0         0         0        for(i=0;i<Nbody;++i)
         .    .    .          .         .         .          .         .         .        {
    36,825    1    1     12,288     6,167         2          9         0         0          tmp_val = pos[l][i];
 5,377,596    5    5          0         0         0          0         0         0          for(j=i+1;j<Nbody;++j)
         .    .    .          .         .         .          .         .         .          {
         .    .    .          .         .         .          .         .         .            // pos[l][j] += tmp_val;
12,817,206    2    2  6,360,684 2,241,383     1,024  6,317,757 3,144,963 3,144,962            delta_pos[l][k] = tmp_val - pos[l][j];
     9,225    0    0          0         0         0          0         0         0            k = k + 1;
         .    .    .          .         .         .          .         .         .          }
         .    .    .          .         .         .          .         .         .        }
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .  // printf("%d\n", k);
         .    .    .          .         .         .          .         .         .  // 8386560 
         .    .    .          .         .         .          .         .         .  // 4*1024=4096
         .    .    .          .         .         .          .         .         .  
-- line 70 ----------------------------------------
-- line 131 ----------------------------------------
         .    .    .          .         .         .          .         .         .      //   {
         .    .    .          .         .         .          .         .         .      //     tmp_val += pow(delta_pos[k][i], 2);
         .    .    .          .         .         .          .         .         .      //   }
         .    .    .          .         .         .          .         .         .      //   delta_r[i] = sqrt(tmp_val);
         .    .    .          .         .         .          .         .         .      // }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .      for(i=Npair-1;i>=0;--i)
         .    .    .          .         .         .          .         .         .      {
         9    1    1          4         0         0          1         1         1        delta_r[i] = 0.0;
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
        14    1    1          0         0         0          0         0         0        for(k=0;k<Ndim;++k)
         .    .    .          .         .         .          .         .         .      {
 9,434,889    0    0          0         0         0          0         0         0          for(i=Npair-1;i>=0;--i)
         .    .    .          .         .         .          .         .         .        {
31,449,604    3    3 12,579,840 6,289,670 5,900,639  6,289,920         0         0          delta_r[i] += pow(delta_pos[k][i], 2);
         .    .    .          .         .         .          .         .         .        }
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
 6,289,932    1    1          0         0         0          0         0         0      for(i=Npair-1;i>=0;--i)
         .    .    .          .         .         .          .         .         .      {
 4,193,280    0    0  2,096,640 1,048,065   684,448  2,096,640         0         0        delta_r[i] = sqrt(delta_r[i]);
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .      /*
         .    .    .          .         .         .          .         .         .       * add pairwise forces.
         .    .    .          .         .         .          .         .         .      */
         .    .    .          .         .         .          .         .         .  
         1    1    1          0         0         0          0         0         0      k = 0;
     8,195    0    0          0         0         0          0         0         0      for(i=0;i<Nbody;++i)
         .    .    .          .         .         .          .         .         .      {
25,192,447    1    1          0         0         0          0         0         0          for(j=i+1;j<Nbody;++j)
         .    .    .          .         .         .          .         .         .          {
 8,394,750    1    1  8,390,655 1,037,254       512          0         0         0              size = radius[i] + radius[j];
 8,394,751    1    1  8,390,656 1,039,150       514          0         0         0              tmp_val2 = G*mass[i]*mass[j];
 8,386,560    0    0  8,386,560 1,048,321 1,048,321          0         0         0              tmp_val3 = delta_r[k];
         .    .    .          .         .         .          .         .         .  
16,773,120    0    0          0         0         0          0         0         0              if( tmp_val3 >= size )
         .    .    .          .         .         .          .         .         .              {
         .    .    .          .         .         .          .         .         .                for(l=0;l<Ndim;l++)
         .    .    .          .         .         .          .         .         .                {
         .    .    .          .         .         .          .         .         .                  tmp_val = force(tmp_val2, delta_pos[l][k], tmp_val3);
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .                  /*  flip force if close in */
50,319,360    0    0 25,159,680 3,106,319     1,536 25,159,680         0         0                  f[l][j] += tmp_val;
83,865,600    3    3 25,159,680     1,365         3 25,159,680         0         0                  f[l][i] -= tmp_val;
         .    .    .          .         .         .          .         .         .                }
         .    .    .          .         .         .          .         .         .              }
         .    .    .          .         .         .          .         .         .              else
         .    .    .          .         .         .          .         .         .              {
         .    .    .          .         .         .          .         .         .                for(l=0;l<Ndim;l++)
         .    .    .          .         .         .          .         .         .                {
         .    .    .          .         .         .          .         .         .                  tmp_val = force(tmp_val2, delta_pos[l][k], tmp_val3);
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .                  /*  flip force if close in */
         .    .    .          .         .         .          .         .         .                  f[l][j] -= tmp_val;
         .    .    .          .         .         .          .         .         .                  f[l][i] += tmp_val;
         .    .    .          .         .         .          .         .         .                }
         1    0    0          1         1         1          0         0         0                collisions++;
         .    .    .          .         .         .          .         .         .              }
 8,386,560    1    1          0         0         0          0         0         0              k = k + 1;
         .    .    .          .         .         .          .         .         .          }
         .    .    .          .         .         .          .         .         .        }
         .    .    .          .         .         .          .         .         .  
        19    1    1          1         0         0          0         0         0      for(i=Ndim-1;i>=0;--i)
         .    .    .          .         .         .          .         .         .      {
     2,343    2    2          0         0         0          0         0         0        for(j=Nbody-1;j>=0;--j)
         .    .    .          .         .         .          .         .         .        {
         .    .    .          .         .         .          .         .         .          /* update positions */
    13,056    4    4      6,144     3,078     3,078      3,072         0         0          pos[i][j] += dt * velo[i][j];
         .    .    .          .         .         .          .         .         .          /* update velocities */
    12,291    1    1      6,144     3,078     1,209      3,072         0         0          velo[i][j] += dt * (f[i][j]/mass[j]);
         .    .    .          .         .         .          .         .         .        }
         .    .    .          .         .         .          .         .         .      }
         .    .    .          .         .         .          .         .         .  
         .    .    .          .         .         .          .         .         .    }
         .    .    .          .         .         .          .         .         .  
         6    0    0          3         1         1          0         0         0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /lustre/home/d167/s1770309/PP/performance_programming_coursework/src/util.h
--------------------------------------------------------------------------------
        Ir I1mr ILmr         Dr      D1mr      DLmr    Dw  D1mw  DLmw 

-- line 2 ----------------------------------------
         .    .    .          .         .         .     .     .     .  #define UTIL
         .    .    .          .         .         .     .     .     .  
         .    .    .          .         .         .     .     .     .  #include <math.h>
         .    .    .          .         .         .     .     .     .  
         .    .    .          .         .         .     .     .     .  inline void
         .    .    .          .         .         .     .     .     .  visc_force (int N, double *f, double *vis, double *velo)
         .    .    .          .         .         .     .     .     .  {
         .    .    .          .         .         .     .     .     .    int i;
     2,352    3    3          0         0         0     0     0     0    for (i = 0; i < N; i++)
         .    .    .          .         .         .     .     .     .      {
     9,984    2    2      6,144     1,542         1 3,072 1,539 1,539        f[i] = -vis[i] * velo[i];
         .    .    .          .         .         .     .     .     .      }
         .    .    .          .         .         .     .     .     .  }
         .    .    .          .         .         .     .     .     .  
         .    .    .          .         .         .     .     .     .  inline void
         3    0    0          0         0         0     0     0     0  wind_force (int N, double *f, double *vis, double velo)
         .    .    .          .         .         .     .     .     .  {
         .    .    .          .         .         .     .     .     .    int i;
     2,337    1    1          0         0         0     0     0     0    for (i = 0; i < N; i++)
         .    .    .          .         .         .     .     .     .      {
     6,912    1    1      3,072     1,539         0 3,072     0     0        f[i] = f[i] - vis[i] * velo;
         .    .    .          .         .         .     .     .     .      }
         .    .    .          .         .         .     .     .     .  }
         .    .    .          .         .         .     .     .     .  
         .    .    .          .         .         .     .     .     .  // inline void add_norm(int N,double *r, double *delta)
         .    .    .          .         .         .     .     .     .  // {
         .    .    .          .         .         .     .     .     .  //   int k;
         .    .    .          .         .         .     .     .     .  //         for(k=0;k<N;k++){
         .    .    .          .         .         .     .     .     .  //           r[k] += pow(delta[k],2.0);
         .    .    .          .         .         .     .     .     .  //         }
         .    .    .          .         .         .     .     .     .  // }
         .    .    .          .         .         .     .     .     .  
         .    .    .          .         .         .     .     .     .  inline double
         .    .    .          .         .         .     .     .     .  force (double W, double delta, double r)
         .    .    .          .         .         .     .     .     .  {
67,104,768    1    1 25,162,752 3,146,501 3,144,962     0     0     0    return W * delta / (pow (r, 3.0));
         .    .    .          .         .         .     .     .     .  }
         .    .    .          .         .         .     .     .     .  
         .    .    .          .         .         .     .     .     .  #endif

--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 
--------------------------------------------------------------------------------
63    4    4 80  100  100 43   75   75  percentage of events annotated

